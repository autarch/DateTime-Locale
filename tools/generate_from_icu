#!/usr/bin/perl -w

#############################################################################
# Source: Ridas::Locale::ICU::Language
#         Ridas::Locale::ICU::Territory

#############################################################################
# Source: Ridas::Locale::ICU::Cache
#         Ridas::Locale::ICU::Calendar
#         Ridas::Locale::ICU::Common
#         Ridas::Locale::ICU::JavaPatterns

#############################################################################
# Source: Ridas::Locale::ICU::JavaPatterns

#############################################################################
# Source: Ridas::Locale::ICU::ICUtoPOSIXConverter
#
# Code provided by Rick Measham (cheers mate!)

#############################################################################
# Source: Ridas::Locale::ICU::makeDateTimeLocale.pl

use strict;

use 5.008;

use DateTime;
use File::Basename;
use File::Copy;
use File::Spec;
use Getopt::Long;
use XML::Simple;

my $VERSION = "0.01";

my ( %XML, %XMLCache, %LanguageLookup, %TerritoryLookup );

my $ScriptName = basename($0);

my %Aliases =
    (
     'C'             => 'en_US_POSIX',
     'iw'            => 'he',
     'iw_IL'         => 'he_IL',
     'POSIX'         => 'en_US_POSIX',

     # Alias some of the less useful ICU locale ids
     'ca_ES_PREEURO' => 'ca_ES',
     'de_AT_PREEURO' => 'de_AT',
     'de_DE_PREEURO' => 'de_DE',
     'de_LU_PREEURO' => 'de_LU',
     'el_GR_PREEURO' => 'el_GR',
     'en_BE_PREEURO' => 'en_BE',
     'en_GB_EURO'    => 'en_GB',
     'en_IE_PREEURO' => 'en_IE',
     'es_ES_PREEURO' => 'es_ES',
     'eu_ES_PREEURO' => 'eu_ES',
     'fi_FI_PREEURO' => 'fi_FI',
     'fr_BE_PREEURO' => 'fr_BE',
     'fr_FR_PREEURO' => 'fr_FR',
     'fr_LU_PREEURO' => 'fr_LU',
     'ga_IE_PREEURO' => 'ga_IE',
     'gl_ES_PREEURO' => 'gl_ES',
     'it_IT_PREEURO' => 'it_IT',
     'nl_BE_PREEURO' => 'nl_BE',
     'nl_NL_PREEURO' => 'nl_NL',
     'pt_PT_PREEURO' => 'pt_PT',
     'no_NO_NY'      => 'no_NO',
    );

# it's an array because the order in which the regexes are checked is
# important
my @JavaPatterns =
    ( qr/G/     => '{era}',
      qr/yyyy/  => '{ce_year}',
      qr/y/     => 'y',
      qr/u/     => 'Y',
      qr/MMMM/  => 'B',
      qr/MMM/   => 'b',
      qr/MM/    => 'm',
      qr/M/     => '{month}',
      qr/dd/    => 'd',
      qr/d/     => '{day}',
      qr/hh/    => 'l',
      qr/h/     => '{hour_12}',
      qr/HH/    => 'H',
      qr/H/     => '{hour}',
      qr/mm/    => 'M',
      qr/m/     => '{minute}',
      qr/ss/    => 'S',
      qr/s/     => '{second}',
      qr/S/     => 'N',
      qr/EEEE/  => 'A',
      qr/E/     => 'a',
      qr/D/     => 'j',
      qr/F/     => '{weekday_of_month}',
      qr/w/     => 'V',
      qr/W/     => '{week_month}',
      qr/a/     => 'p',
      qr/k/     => '{hour_1}',
      qr/K/     => '{hour_12_0}',
      qr/z/     => '{time_zone_long_name}',
    );

my %opts;

main();

sub main
{
    GetOptions( 'dir:s'  => \$opts{dir},
                'name:s' => \$opts{name},
                'quiet'  => \$opts{quiet},
                'help'   => \$opts{help},
              );

    $opts{help} = 1
        unless defined $opts{dir} && -d $opts{dir};

    usage() if $opts{help};

    unless ( $opts{name} )
    {
        copy( 'MANIFEST.base', 'MANIFEST' );
        open MAN, ">>MANIFEST" or die "Cannot write to MANIFEST: $!";
    }

    generate_from_ICU_xml();
}

sub generate_from_ICU_xml
{
    my @files = glob File::Spec->catfile( $opts{dir}, '*.xml' );

    print "Reading ICU files from: '$opts{dir}'...\n\n"
        unless $opts{quiet};

    foreach my $f (@files)
    {
        my $id = basename($f)
            or die "Could not get basename for: '$f'";
        $id =~ s/\.xml$//i;

        print "  $id" unless $opts{quiet};

        if ( $Aliases{$id} )
        {
            print " - is an alias, skipping\n" unless $opts{quiet};
            next;
        }

        my $xml =
            XMLin($f)
                or die "Missing XML for locale: '$id'";

        $XML{$id} = { xml         => $xml,
                      source_file => basename($f),
                    };

        build_language_and_territory($id, $xml);

        print "\n" unless $opts{quiet};
    }

    foreach my $id ( sort keys %XML )
    {
        my $xml = $XML{$id}{xml};

        unless ( has_data($xml) )
        {
            my $parent = parent_id($id);
            $Aliases{$id} = $parent;
            print "  $id has no data - making it an alias for $parent\n"
                unless $opts{quiet};
            next;
        }

        my $hash;
        $hash->{id}        = $id;
        $hash->{parent_id} = parent_id($id);

        get_version( $hash, $xml );
        get_generation_date( $hash, $xml );
        get_days( $hash, $xml );
        get_months( $hash, $xml );
        get_formats( $hash, $xml );
        get_am_pm_eras( $hash, $xml );

        user_supplied_changes($hash);

        generate_locale($hash);
    }

    generate_name_lookup();

    print "\nAll done\n" unless $opts{quiet};
}

sub build_language_and_territory
{
    my ($id, $xml) = @_;

    _build_lookup
        ( \%LanguageLookup,  $id, $xml->{localeDisplayNames}{languages}{language} );

    _build_lookup
        ( \%TerritoryLookup, $id, $xml->{localeDisplayNames}{territories}{territory} );
}

sub _build_lookup
{
    my ($lookup, $id, $xml) = @_;

    return unless $xml;

    ($id) = split /_/, $id;          # Interested in language only

    if ( ref $xml eq "HASH" )
    {
        $lookup->{$id}{ $xml->{type} } = $xml->{content};
    }
    else
    {
        $lookup->{$id}{ $_->{type} } = $_->{content} for @$xml;
    }
}

sub has_data
{
    my $cal = shift()->{dates}{calendars}{calendar};

    return
        ( $cal->{dayNames}{day}                ||
          $cal->{dayAbbr}{day}                 ||
          $cal->{monthNames}{month}            ||
          $cal->{monthAbbr}{month}             ||
          $cal->{am}                           ||
          $cal->{eras}{eraAbbr}{era}           ||
          $cal->{dateFormats}{dateFormatStyle} ||
          $cal->{timeFormats}{timeFormat}      ||
          $cal->{dateTimeFormat}{pattern}
        );
}

sub parent_id
{
    my $id = shift;

    my ($language, $territory, $variant) = split /_/, $id;

    my $parent_id;

    if ( $territory )
    {
        $parent_id  =   $language;
        $parent_id .= "_$territory" if $variant;
    }
    else
    {
        $parent_id = $language =~ /^root$/i ? 'Base' : 'root';
    }

    if ( $Aliases{$parent_id} )
    {
        return parent_id($parent_id);
    }

    return $parent_id;
}

sub get_version
{
    my ( $hash, $xml ) = @_;

    $hash->{version} = $xml->{identity}{version}{number};
}

sub get_generation_date
{
    my ( $hash, $xml ) = @_;

    $hash->{generation_date} = $xml->{identity}{generation}{date};
}

sub get_days
{
    my ($hash, $xml) = @_;

    _get_days($hash, $xml, 'dayNames', 'day_names'        );
    _get_days($hash, $xml, 'dayAbbr',  'day_abbreviations');
}

sub _get_days
{
    my ($hash, $xml, $element, $key) = @_;

    return unless my $days = $xml->{dates}{calendars}{calendar}{$element}{day};

    $hash->{$key}[6]      = $days->[ 0]{content};
    $hash->{$key}[$_ - 1] = $days->[$_]{content} for 1..6;
}

sub get_months
{
    my ($hash, $xml) = @_;

    _get_months($hash, $xml, 'monthNames', 'month_names'        );
    _get_months($hash, $xml, 'monthAbbr',  'month_abbreviations');
}

sub _get_months
{
    my ($hash, $xml, $element, $key) = @_;

    return unless my $months = $xml->{dates}{calendars}{calendar}{$element}{month};

    $hash->{$key}[$_] = $months->[$_]{content} for 0..11;
}

sub get_am_pm_eras
{
    my ($hash, $xml) = @_;

    my $cal = $xml->{dates}{calendars}{calendar};

    $hash->{am_pms} = [ $cal->{am}, $cal->{pm} ] if $cal->{am};

    $hash->{eras} =
        [ $cal->{eras}{eraAbbr}{era}[0]{content},
          $cal->{eras}{eraAbbr}{era}[1]{content} ]
            if $cal->{eras}{eraAbbr}{era};
}

sub get_formats
{
    my ($hash, $xml) = @_;

    if ( my $dates = $xml->{dates}{calendars}{calendar}{dateFormats}{dateFormatStyle} )
    {
        $hash->{date_formats}[$_] = simple2strf( $dates->[$_]{dateFormat}{pattern} )
            for ( 0..3 );
    }

    if ( my $times = $xml->{dates}{calendars}{calendar}{timeFormats}{timeFormat} )
    {
        $hash->{time_formats}[$_] = simple2strf( $times->[$_]{pattern} )
            for ( 0..3 );
    }

    if ( my $order = $xml->{dates}{calendars}{calendar}{dateTimeFormat}{pattern} )
    {
        $hash->{date_time_format_pattern_order} =
            $order eq "{1} {0}" ? [1, 0] : [0, 1];
    }
}

sub simple2strf
{
    my $simple = shift;
    $simple =~
        s/(G+|y+|u+|M+|d+|h+|H+|m+|s+|S+|E+|D+|F+|w+|W+|a+|k+|K+|z+)|'((?:[^']|'')*)'/
          ($2) ? _stringify($2) : ($1) ? _convert($1) : "'"/eg;

    return $simple;
}

sub _convert
{
    my $simple = shift;

    for ( my $x = 0; $x < @JavaPatterns; $x += 2 )
    {
        return '%' . $JavaPatterns[ $x + 1 ] if $simple =~ /$JavaPatterns[$x]/;
    }

    die "**Dont know $simple***";
}

sub _stringify
{
    my $string = shift;

    $string =~ s/%(?:[^%])/%%/g;
    $string =~ s/\'\'/\'/g;

    return $string;
}

sub user_supplied_changes
{
    my $hash = shift;

    if ( $hash->{id} eq 'nl' )
    {
        # Eugene Van Der Pijll <pijll@gmx.net>
        # Thursday 01 May 2003 10:14:35 pm
        # datetime@perl.org

        $hash->{eras} = ["v.Chr.", "n.Chr."];
    }
}

sub generate_name_lookup
{
    open OUTFILE, '>:utf8', File::Spec->catfile( 'lib', 'DateTime', 'LocaleCatalog.pm' )
        or die "$!";

    print OUTFILE <<'EOF';
package DateTime::LocaleCatalog;

use strict;

BEGIN
{
    return unless $] >= 5.006;

    require utf8; import utf8;
}

EOF

    my $locales_in_pod = '';

    print OUTFILE "\@DateTime::Locale::Locales = (\n";

    for my $id ( sort keys %XML )
    {
        my ($lang, $territory, $variant) = split /_/, $id;

        my %lookup;

        $lookup{en_language} = $LanguageLookup{root}{$lang};
        $lookup{en_complete_name} = $lookup{en_language};
        $lookup{native_language} =
            $LanguageLookup{$lang}{$lang} || $LanguageLookup{root}{$lang};
        $lookup{native_complete_name} = $lookup{native_language};

        if ($territory)
        {
            $lookup{en_territory} = $TerritoryLookup{root}{$territory};;
            $lookup{en_complete_name} .= ' ' . $lookup{en_territory};

            $lookup{native_territory} =
                ( exists $TerritoryLookup{$lang}{$territory}
                  ? $TerritoryLookup{$lang}{$territory}
                  : $TerritoryLookup{root}{$territory} );

            $lookup{native_complete_name} .= ' ' . $lookup{native_territory};
        }

        if ($variant)
        {
            $lookup{en_variant} = ucfirst lc $variant;

            $lookup{en_complete_name} .= ' ' . $lookup{en_variant};
            $lookup{native_complete_name} .= ' ' . $lookup{en_variant};
        }
        else
        {
            $lookup{en_variant} = undef;
        }

        $lookup{native_variant} = $lookup{en_variant};

        print OUTFILE qq|    { id => "\Q$id\E",\n|;
        foreach my $k ( qw( en_complete_name native_complete_name
                            en_language en_territory en_variant
                            native_language native_territory native_variant
                          )
                      )
        {
            my $val = defined $lookup{$k} ? qq|"\Q$lookup{$k}\E"| : 'undef';
            print OUTFILE "      $k => $val,\n";
        }

        print OUTFILE "    },\n";

        $locales_in_pod .= sprintf( " %-18s  %s\n", $id, $lookup{en_complete_name} );
    }

    print OUTFILE ");\n\n";

    print OUTFILE "%DateTime::Locale::Aliases = (\n";
    foreach my $id ( sort keys %Aliases )
    {
        print OUTFILE "    $id => '$Aliases{$id}',\n";
    }
    print OUTFILE ");";

    print OUTFILE <<"EOF";


1;

__END__

=head1 NAME

DateTime::LocaleCatalog - Provides a list of all valid locale names

=head1 SYNOPSIS

See DateTime::Locale for usage details.

=head1 DESCRIPTION

This module contains a list of all known locales.

=head1 LOCALES

Many of the available locales are the same as other, more generic
locales for datetime information.  In that case, we simply load the
more generic class.  However, the various methods related to name,
territory, and variant return the values for the requested locale.

The available locales are:

 Locale id           Locale name
 ==================================================
$locales_in_pod

=cut
EOF

    close OUTFILE or warn $!;
}

sub generate_locale
{
    my $hash = shift;

    my $vars = "";
    my $subs = "";

    for ( qw( date_time_format_pattern_order
              day_names
              day_abbreviations
              month_names
              month_abbreviations
              am_pms
              eras
              date_formats
              time_formats ) )
    {
        next unless $hash->{$_};

        $vars .= "my \$$_ = [\n" . join("", map { s/\'/\\\'/g; "  '$_',\n" } @{$hash->{$_}}) . "];\n\n";
        $subs .= sprintf "sub %-30s { \$%-30s }\n", $_, $_;
    }

    my $class         = $hash->{id};
    my $parent        = $hash->{parent_id};

    my $id = $hash->{id};

    my $file = File::Spec->catfile( 'lib', 'DateTime', 'Locale', "$class.pm");
    open OUTFILE, ">:utf8", $file or die $!;
    print OUTFILE <<"EOF" or die "print failed: $!";
###########################################################################
#
# This file is auto-generated by the Perl DateTime Suite time locale
# generator ($VERSION).  This code generator comes with the
# DateTime::Locale distribution in the tools/ directory, and is called
# $ScriptName.
#
# This file as generated from the ICU XML locale data.  See the
# LICENSE.icu file included in this distribution for license details.
#
# This file was generated from the source file $XML{$id}{source_file}.
# The source file version number was $hash->{version}, generated on
# $hash->{generation_date}.
#
# Do not edit this file directly.
#
###########################################################################

package DateTime::Locale::$class;

use strict;

BEGIN
{
    if ( \$] >= 5.006 )
    {
        require utf8; utf8->import;
    }
}

use DateTime::Locale::$parent;

\@DateTime::Locale::${class}::ISA = qw(DateTime::Locale::$parent);

$vars

$subs

1;

EOF

    close OUTFILE or warn $!;

    print MAN "$file\n";
}

sub usage
{
    print <<'EOF';

This script parses the ICU locale files and turns them into a set of
Perl modules.  It also generates the MANIFEST file.

It takes the following arguments:

  --dir   A directory containing ICU XML files.  Required.

  --file  Parse just the file with the given name.  For debugging.

  --name  Only create the specified locale.  For debugging.

  --help  What you are reading

If the --file or --name options are specified, the MANIFEST will not
be generated.

EOF

    exit;
}
